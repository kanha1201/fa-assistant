"""Guardrails and safety constraints for the chatbot."""
import re
from typing import Dict, List, Tuple, Optional


class ChatbotGuardrails:
    """Guardrails for compliant chatbot behavior."""
    
    # Banned emotional words
    BANNED_WORDS = [
        "multibagger", "skyrocketing", "cheap", "jackpot", "safe", "guaranteed",
        "sure thing", "must buy", "definitely", "certainly", "absolutely",
        "huge gains", "massive returns", "get rich", "best stock", "top pick"
    ]
    
    # Allowed neutral words
    ALLOWED_WORDS = [
        "undervalued", "overvalued", "growing", "declining", "stable", "volatile",
        "improving", "deteriorating", "reasonable", "elevated", "moderate"
    ]
    
    # Patterns for advisory questions
    ADVISORY_PATTERNS = [
        r"should i (buy|sell|invest|purchase)",
        r"do you (recommend|suggest|advise)",
        r"is it (good|bad|worth) (to|for) (buy|sell|invest)",
        r"would you (buy|sell|invest)",
        r"can i (buy|sell|invest)",
        r"tell me (if|whether) (i|to) (should|can) (buy|sell)",
        r"advice|recommendation|suggestion",
        r"what (should|would) (i|you) (do|buy|sell)",
    ]
    
    # Patterns for predictive questions
    PREDICTIVE_PATTERNS = [
        r"(target|future|next|tomorrow|next month|next year|will|forecast|prediction)",
        r"what (will|would) (happen|be|price)",
        r"(predict|forecast|expect) (price|value|performance)",
        r"where (will|would) (it|the stock|price) (be|go|reach)",
    ]
    
    # Greeting patterns (must match entire query)
    GREETING_PATTERNS = [
        r"^(hi|hello|hey|greetings|good (morning|afternoon|evening))$",
        r"^(thanks|thank you|thx)$",
        r"^(bye|goodbye|see you)$",
    ]
    
    @staticmethod
    def is_advisory_question(query: str) -> bool:
        """Check if query is asking for investment advice."""
        query_lower = query.lower()
        for pattern in ChatbotGuardrails.ADVISORY_PATTERNS:
            if re.search(pattern, query_lower):
                return True
        return False
    
    @staticmethod
    def is_predictive_question(query: str) -> bool:
        """Check if query is asking for predictions."""
        query_lower = query.lower()
        for pattern in ChatbotGuardrails.PREDICTIVE_PATTERNS:
            if re.search(pattern, query_lower):
                return True
        return False
    
    @staticmethod
    def is_greeting(query: str) -> bool:
        """Check if query is a greeting."""
        query_lower = query.strip().lower()
        # Only match if the entire query is a greeting (not just contains greeting words)
        for pattern in ChatbotGuardrails.GREETING_PATTERNS:
            if re.match(pattern, query_lower):
                return True
        return False
    
    @staticmethod
    def contains_personalized_advice(text: str) -> bool:
        """Check if text contains personalized advice."""
        # Look for "you" in portfolio/recommendation context
        patterns = [
            r"you (should|must|can|may) (buy|sell|invest|hold)",
            r"since you (hold|own|have)",
            r"your (portfolio|investment|holding)",
        ]
        text_lower = text.lower()
        for pattern in patterns:
            if re.search(pattern, text_lower):
                return True
        return False
    
    @staticmethod
    def filter_emotional_words(text: str) -> str:
        """Remove or replace emotional words with neutral alternatives."""
        words = text.split()
        filtered_words = []
        
        for word in words:
            word_lower = word.lower().strip('.,!?;:')
            if word_lower in ChatbotGuardrails.BANNED_WORDS:
                # Replace with neutral alternative
                replacements = {
                    "multibagger": "high-growth potential",
                    "skyrocketing": "growing rapidly",
                    "cheap": "undervalued",
                    "jackpot": "significant opportunity",
                    "safe": "stable",
                    "guaranteed": "expected",
                }
                replacement = replacements.get(word_lower, "significant")
                filtered_words.append(replacement)
            else:
                filtered_words.append(word)
        
        return " ".join(filtered_words)
    
    @staticmethod
    def add_disclaimer(text: str, feature_type: Optional[str] = None) -> str:
        """Add standardized disclaimer."""
        disclaimer = "\n\n*Generated by AI based on public data. Not a buy/sell recommendation. Please consult your financial advisor.*"
        
        # Add feature-specific disclaimer if needed
        if feature_type in ["bull_bear", "red_flags", "benchmark"]:
            return text + disclaimer
        
        return text
    
    @staticmethod
    def handle_advisory_refusal(query: str, context_data: Dict) -> str:
        """Generate appropriate refusal for advisory questions."""
        # Extract relevant information for context
        red_flags = []
        benchmarks = []
        
        # Check if we have red flags or benchmark data
        if "red_flags" in str(context_data).lower():
            red_flags.append("red flags identified")
        
        response = "I cannot provide buy/sell recommendations or investment advice. "
        response += "However, I can help you analyze the company's financial metrics and performance. "
        
        if red_flags:
            response += "Based on the available data, there are certain risk factors to consider. "
        
        response += "Please consult a qualified financial advisor for personalized investment advice."
        
        return response
    
    @staticmethod
    def handle_predictive_refusal(query: str) -> str:
        """Generate appropriate refusal for predictive questions."""
        return "I cannot predict future stock prices, market movements, or company performance. " \
               "I can only analyze past performance, current financial metrics, and historical data. " \
               "For future projections, please consult a qualified financial advisor."
    
    @staticmethod
    def handle_greeting(query: str) -> str:
        """Handle greeting queries."""
        query_lower = query.strip().lower()
        
        if re.match(r"^(hi|hello|hey|greetings)", query_lower):
            return "Hello! How can I help you today? I can assist you with analyzing Eternal Limited's financial data, including fundamentals, metrics, and quarterly results."
        elif re.match(r"^(thanks|thank you|thx)", query_lower):
            return "You're welcome! Feel free to ask if you need any more information."
        elif re.match(r"^(bye|goodbye|see you)", query_lower):
            return "Goodbye! Feel free to return if you have more questions."
        else:
            return "Hello! How can I help you today?"
    
    @staticmethod
    def handle_data_unavailable(metric_name: str) -> str:
        """Handle unavailable data gracefully."""
        return f"I'm still learning, and the information about {metric_name} is not available with me right now, but will soon be available. " \
               "In the meantime, I can help you with other financial metrics and analysis that are currently available."
    
    @staticmethod
    def add_citations(text: str, sources: List[Dict]) -> str:
        """Add source citations to text."""
        if not sources:
            return text
        
        citation_section = "\n\n**Sources:**\n"
        for i, source in enumerate(sources, 1):
            source_type = source.get("type", "data")
            source_url = source.get("url", "")
            if source_url:
                citation_section += f"{i}. {source_type}: {source_url}\n"
            else:
                citation_section += f"{i}. {source_type}\n"
        
        return text + citation_section
    
    @staticmethod
    def ensure_neutral_tone(text: str) -> str:
        """Ensure neutral tone throughout the response."""
        # Filter emotional words
        text = ChatbotGuardrails.filter_emotional_words(text)
        
        # Remove personalized advice
        if ChatbotGuardrails.contains_personalized_advice(text):
            # Replace "you" with neutral alternatives where appropriate
            text = re.sub(r"\byou should\b", "one may consider", text, flags=re.IGNORECASE)
            text = re.sub(r"\byou can\b", "investors can", text, flags=re.IGNORECASE)
            text = re.sub(r"\bsince you\b", "for investors who", text, flags=re.IGNORECASE)
        
        return text


guardrails = ChatbotGuardrails()

